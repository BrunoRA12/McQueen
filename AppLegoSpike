import asyncio
import threading
import tempfile
import os
from queue import Queue, Empty
import tkinter as tk
from tkinter import ttk

from pybricksdev.ble import find_device
from pybricksdev.connections.pybricks import PybricksHubBLE

# worker BLE maneja toda la conexion bluetooth low energy en un hilo separado de la GUI para evitar que esta se congele mientras se transmiten datos
# -------------------- WORKER BLE --------------------

class BLEWorker:
    def __init__(self, log_queue: Queue):
        self.loop = asyncio.new_event_loop()
        self.thread = threading.Thread(target=self._thread_main, daemon=True)
        self.queue = None
        self.hub = None
        self.running = threading.Event()
        self.log_queue = log_queue

    def log(self, msg: str):
        self.log_queue.put(msg)

    def _thread_main(self):
        asyncio.set_event_loop(self.loop)
        self.queue = asyncio.Queue()
        self.loop.create_task(self._runner())
        self.loop.run_forever()

    async def _runner(self):
        try:
            self.log("Buscando unidad autónoma...")
            device = await find_device() # Busca cualquier Hub Pybricks cercano
            if not device:
                self.log("Error: No se encontró el Hub.")
                return

            self.hub = PybricksHubBLE(device)
            
            # PASO CLAVE: Solo conectar. 
            # No usamos hub.run(). El Hub ya debe tener su programa iniciado.
            await self.hub.connect()
            
            self.log("Vinculado al Servidor Autónomo.")
            self.running.set()

            # Bucle de retransmisión
            while True:
                # Espera a que la GUI ponga un comando en la cola
                char_cmd = await self.queue.get()
                
                # Escribe el carácter directamente en el puerto serie BLE
                # El Hub lo recibirá mediante usys.stdin.read(1)
                await self.hub.write(char_cmd.encode())
                
        except Exception as e:
            self.log(f"Error de conexión: {e}")
        finally:
            if self.hub: 
                await self.hub.disconnect()
            self.running.clear()
            self.log("Desconectado.")

    def start(self):
        if not self.thread.is_alive(): 
            self.thread.start()

    def send_command(self, cmd: str):
        mapping = {"fwd": "F", "bwd": "B", "left": "L", "right": "R", "stop": "S"}
        char = mapping.get(cmd)
        if char and self.loop.is_running() and self.queue is not None:
            # Enviamos el comando al bucle de asyncio de forma segura entre hilos
            self.loop.call_soon_threadsafe(self.queue.put_nowait, char)

#La GUI obtiene los inputs desde el teclado o los botones dibujados y genera request de movimiento al hub
# -------------------- GUI --------------------

class LegoGUI:
    def __init__(self, root: tk.Tk):
        self.root = root
        self.root.title("LEGO Keyboard Remote")
        self.root.geometry("400x550")
        
        self.log_queue = Queue()
        self.worker = BLEWorker(self.log_queue)
        
        # Track which keys are currently held down
        self.active_keys = set()

        self._build_ui()
        self._setup_keyboard()
        self._poll_logs()

    def _build_ui(self):
        top = ttk.Frame(self.root, padding=10)
        top.pack(fill='x')
        ttk.Button(top, text="Conectar", command=self.on_connect).pack(side='left', padx=5)
        self.status_label = ttk.Label(top, text="Estado: OFF", foreground="red")
        self.status_label.pack(side='right')

        info = ttk.Label(self.root, text="Usa las FLECHAS del teclado para conducir", font=("Arial", 10, "italic"))
        info.pack(pady=5)

        ctrl_frame = ttk.Labelframe(self.root, text="Controles Visuales", padding=20)
        ctrl_frame.pack(pady=10)

        # Directional Buttons
        self.btns = {}
        def create_btn(text, cmd, row, col):
            btn = ttk.Button(ctrl_frame, text=text)
            btn.grid(row=row, column=col, padx=5, pady=5)
            btn.bind("<ButtonPress>", lambda e: self.worker.send_command(cmd))
            btn.bind("<ButtonRelease>", lambda e: self.worker.send_command("stop"))
            self.btns[cmd] = btn

        create_btn("▲", "fwd", 0, 1)
        create_btn("◄", "left", 1, 0)

        create_btn("►", "right", 1, 2)
        create_btn("▼", "bwd", 2, 1)

        self.log_text = tk.Text(self.root, height=10, state='disabled', font=("Consolas", 9))
        self.log_text.pack(fill='both', expand=True, padx=10, pady=10)

    def _setup_keyboard(self):
        """Binds physical keyboard keys to the worker commands."""
        key_map = {
            "Up": "fwd",
            "Down": "bwd",
            "Left": "left",
            "Right": "right"
        }

        def on_key_press(event):
            if event.keysym in key_map and event.keysym not in self.active_keys:
                cmd = key_map[event.keysym]
                self.active_keys.add(event.keysym)
                self.worker.send_command(cmd)
                # Visual feedback on buttons
                if cmd in self.btns: self.btns[cmd].state(['pressed'])

        def on_key_release(event):
            if event.keysym in key_map:
                cmd = key_map[event.keysym]
                if event.keysym in self.active_keys:
                    self.active_keys.remove(event.keysym)
                
                # Only stop if no other directional keys are held
                if not self.active_keys:
                    self.worker.send_command("stop")
                
                if cmd in self.btns: self.btns[cmd].state(['!pressed'])

        self.root.bind("<KeyPress>", on_key_press)
        self.root.bind("<KeyRelease>", on_key_release)

    def on_connect(self):
        self.status_label.configure(text="Conectando...", foreground="orange")
        self.worker.start()
        self._check_status()

    def _check_status(self):
        if self.worker.running.is_set():
            self.status_label.configure(text="Conectado", foreground="green")
            self.root.focus_set() # Ensure keyboard focus
        else:
            self.root.after(500, self._check_status)

    def _poll_logs(self):
        try:
            while True:
                msg = self.log_queue.get_nowait()
                self.log_text.configure(state='normal')
                self.log_text.insert('end', f"> {msg}\n")
                self.log_text.see('end')
                self.log_text.configure(state='disabled')
        except Empty: pass
        self.root.after(100, self._poll_logs)

if __name__ == '__main__':
    root = tk.Tk()
    app = LegoGUI(root)
    root.mainloop()